1] Linked List Structure and Node Definition :
-------------------------------------------
Each Node will store data and a reference (or pointer) to the next node in the list. Let’s start by creating a Node class and a LinkedList class.

CODE :
------
class Node:
    def __init__(self, data):
        self.data = data  
        self.next = None  
class LinkedList:
    def __init__(self):
        self.head = None  
    
    def __str__(self):
        elements = []
        current = self.head
        while current:
            elements.append(current.data)
            current = current.next
        return " -> ".join(map(str, elements))
        
ll = LinkedList()
print(ll) 

EXPLAINATION :
--------------
1. What is a Node?
In a linked list, a node is the basic building block. Each node stores:

Data (the actual value we want to store in the list).
Pointer to the next node (to maintain the sequence of nodes).
Here’s the Node class:

class Node:
    def __init__(self, data):
        self.data = data  # Data stored in the node
        self.next = None  # Pointer to the next node


__init__ method: This is the constructor, called whenever a new node is created.
self.data: Stores the data value for this node.
self.next: This points to the next node in the sequence. Initially, it is set to None (meaning there is no next node yet).


2. What is a LinkedList?
A linked list is a sequence of nodes where each node points to the next node. The first node in the list is called the head. The list also ends when a node's next is None (indicating the end of the list).

Here’s the LinkedList class:
----------------------------

class LinkedList:
    def __init__(self):
        self.head = None  # Head (first node) of the linked list

__init__ method: This constructor initializes an empty linked list by setting self.head to None.
self.head: Refers to the first node of the list. Initially, it’s None, meaning the list is empty.


3. Printing the Linked List
The __str__ method is used to convert the linked list to a string representation, which makes it easier to print the list's elements.

def __str__(self):
    # Print the entire linked list
    elements = []  # List to store node data
    current = self.head  # Start from the head node
    while current:
        elements.append(current.data)  # Add the data to the list
        current = current.next  # Move to the next node
    return " -> ".join(map(str, elements))

Here’s what this method does:
-----------------------------
elements = []: An empty list to store the data from each node.
current = self.head: Start traversing the list from the first node (head).
while current:: Traverse the list until there are no more nodes (i.e., current becomes None).
elements.append(current.data): Add the current node's data to the elements list.
current = current.next: Move to the next node in the list.
return " -> ".join(map(str, elements)):
Convert the elements list into a string (separating each element with " -> ").
If the list is empty, it will return an empty string.

4. Creating and Printing the Linked List
Now, we create an instance of the LinkedList and print it:
----------------------------------------------------------

# Create an empty linked list
ll = LinkedList()
print(ll)  # Output should be an empty string

ll = LinkedList(): Creates an empty linked list with no nodes.
print(ll): Calls the __str__ method. Since the list is empty (head is None), the elements list remains empty, and the output is an empty string.

5. Expected Output :
--------------------
Since the linked list is empty, the output will be:

(empty string)


6. What Happens if We Add Nodes? :
----------------------------------
If we add nodes to the list, they will be linked together. For example:

# Add some nodes
ll.head = Node(1)  # Head node with value 1
second_node = Node(2)
ll.head.next = second_node  # Link head to second node
third_node = Node(3)
second_node.next = third_node  # Link second to third node

print(ll)  # Output: 1 -> 2 -> 3

Here’s how it works:

We create the first node with data 1 and set it as the head.
We create a second node with data 2 and link it to the first node.
We create a third node with data 3 and link it to the second node.
The list will now look like:
1 -> 2 -> 3

When you print the list, the output will be:

1 -> 2 -> 3


7. Summary
Node class: Represents each element in the linked list.
LinkedList class: Manages the entire linked list, including the head node and printing the list.
__str__ method: Converts the list to a readable string format for printing.
Initial Output: The first output is an empty string since the linked list is empty.





2] Insertion Operations :
-------------------------
There are multiple ways to insert elements into a linked list:

At the beginning.
At the end.
At a specific position.


Insertion at the Beginning:
---------------------------
When inserting a new element at the beginning of the linked list, the new node becomes the new head, and it points to the old head.

CODE :
------
def insert_at_beginning(self, data):
    new_node = Node(data)  # Create a new node
    new_node.next = self.head  # Point the new node to the current head
    self.head = new_node  # Update the head to the new node


How it Works:
-------------
Create a new node with the given data.
Make the next of the new node point to the current head.
Update the head to the new node.

Example:
--------

ll = LinkedList()
ll.insert_at_beginning(10)  # List becomes: 10
print(ll)  # Output: 10


If you insert more elements at the beginning, the list grows backward.



 
2] Insertion at the End:
 ---------------------
 Inserting a new element at the end involves traversing the entire list to find the last node (where next is None).
 
 CODE :
 ------
 
 def insert_at_end(self, data):
    new_node = Node(data)  # Create a new node
    if not self.head:  # If the list is empty
        self.head = new_node
        return
    current = self.head
    while current.next:  # Traverse to the last node
        current = current.next
    current.next = new_node  # Add the new node at the end

How it Works:
-------------
Create a new node with the given data.
If the list is empty (head is None), make the new node the head.
Otherwise, traverse the list until the last node.
Make the next of the last node point to the new node.

Example:
--------
ll.insert_at_end(20)  # List becomes: 10 -> 20
print(ll)  # Output: 10 -> 20


 
Insertion at a Specific Position:
---------------------------------

This operation allows inserting a new node at a given position (index-based).

If the position is 0, it behaves like insertion at the beginning.
If the position is beyond the list’s length, raise an IndexError.

CODE :
------

def insert_at_position(self, data, position):
    if position < 0:
        raise IndexError("Invalid position")  # Handle negative indices
    new_node = Node(data)  # Create a new node
    if position == 0:  # Special case: Insert at beginning
        new_node.next = self.head
        self.head = new_node
        return
    current = self.head  # Start from the head
    for _ in range(position - 1):  # Traverse to the (position-1)th node
        if not current:
            raise IndexError("Position out of bounds")  # Handle invalid position
        current = current.next
    new_node.next = current.next  # Link the new node to the next node
    current.next = new_node  # Link the (position-1)th node to the new node

How it Works:
-------------
Check if the position is valid (non-negative).
If the position is 0, insert at the beginning.
Otherwise, traverse to the (position - 1)th node.
Insert the new node by updating the pointers.

Example:
--------

ll.insert_at_position(15, 1)  # Insert 15 at index 1
print(ll)  # Output: 10 -> 15 -> 20


Add these methods to the LinkedList class and test:
---------------------------------------------------
ll = LinkedList()
ll.insert_at_beginning(10)
ll.insert_at_end(20)
ll.insert_at_position(15, 1)  # Insert 15 at index 1
print(ll)  # Output: 10 -> 15 -> 20



 Full Code with Test Cases :
 ---------------------------
Here’s the complete code with the new insertion methods:

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def __str__(self):
        elements = []
        current = self.head
        while current:
            elements.append(current.data)
            current = current.next
        return " -> ".join(map(str, elements))

    def insert_at_beginning(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def insert_at_end(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node

    def insert_at_position(self, data, position):
        if position < 0:
            raise IndexError("Invalid position")
        new_node = Node(data)
        if position == 0:
            new_node.next = self.head
            self.head = new_node
            return
        current = self.head
        for _ in range(position - 1):
            if not current:
                raise IndexError("Position out of bounds")
            current = current.next
        new_node.next = current.next
        current.next = new_node

# Test the LinkedList
ll = LinkedList()
ll.insert_at_beginning(10)  # List: 10
ll.insert_at_end(20)         # List: 10 -> 20
ll.insert_at_position(15, 1) # List: 10 -> 15 -> 20

print(ll)  # Output: 10 -> 15 -> 20




3. Deletion Operations :
------------------------
Here’s a detailed explanation of the three ways to delete elements from a linked list:

Deleting the first node
Deleting the last node
Deleting a node at a specific position

There are three cases for deletion:
-----------------------------------
1. Deleting the first node.
2. Deleting the last node.
3. Deleting a node at a specific position.


Deleting the First Node:
------------------------
CODE :
-----

def delete_first(self):
    if not self.head:  # If the list is empty
        raise Exception("List is empty")
    self.head = self.head.next  # Move the head to the next node

How it Works:
-------------
Check if the list is empty. If it is, raise an exception.
Update the head to the second node by assigning self.head = self.head.next.

Example:
--------
ll.delete_first()  # List: 10 -> 15 -> 20 becomes 15 -> 20
print(ll)  # Output: 15 -> 20



Deleting the Last Node:
-----------------------
This operation removes the last node by traversing to the second-last node and updating its next pointer to None.

CODE :
------
def delete_last(self):
    if not self.head:  # If the list is empty
        raise Exception("List is empty")
    if not self.head.next:  # If there is only one node
        self.head = None
        return
    current = self.head  # Start from the head
    while current.next.next:  # Traverse to the second-last node
        current = current.next
    current.next = None  # Remove the last node

How it Works:
-------------
Check if the list is empty. If it is, raise an exception.
If there is only one node, set self.head = None.
Otherwise, traverse to the second-last node.
Set the next pointer of the second-last node to None to remove the last node.

Example:
--------
ll.delete_last()  # List: 15 -> 20 becomes 15
print(ll)  # Output: 15




Deleting at a Specific Position:
--------------------------------
This operation removes a node at a specific index by updating the next pointer of the previous node.

CODE :
------

def delete_at_position(self, position):
    if position < 0:  # Check for invalid index
        raise IndexError("Invalid position")
    if not self.head:  # If the list is empty
        raise Exception("List is empty")
    if position == 0:  # If deleting the first node
        self.head = self.head.next
        return
    current = self.head
    for _ in range(position - 1):  # Traverse to the (position-1)th node
        if not current.next:
            raise IndexError("Position out of bounds")
        current = current.next
    current.next = current.next.next  # Skip over the node to be deleted

How it Works:
-------------
Check if the index is valid (non-negative).
If the list is empty, raise an exception.
If the position is 0, remove the first node by updating the head.
Traverse to the (position - 1)th node.
Skip over the node to be deleted by updating the next pointer.

Example:
--------
ll.insert_at_end(30)  # Add some nodes to delete: 15 -> 30
ll.delete_at_position(1)  # Delete node at position 1 (30)
print(ll)  # Output: 15


Complete Code with Deletion Methods :
-------------------------------------
Here’s the full code, including insertion and deletion methods:


class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def __str__(self):
        elements = []
        current = self.head
        while current:
            elements.append(current.data)
            current = current.next
        return " -> ".join(map(str, elements))

    def insert_at_beginning(self, data):
        new

